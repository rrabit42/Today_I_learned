# 테스트  
피라미드 -> 1로 갈수록 값비쌈
1. UI: 전체 시스템 테스트  
2. 서비스: 통합 테스트(service level integration test)  
3. 유닛: 단위 테스트(unit test)  

외부에서 내부로 개발하기(out-in development) 프로세스  
피라미드 위쪽에 있는 테스트를 작성하는 것으로 시작  
-> 작업 중인 스토리(story)의 기능을 결정  
-> 이 스토리에 대한 실패하는 테스트  
-> 행위 기반 테스트에서 통과(pass)해야 하는 여러 단계에 맞춰 단위 테스트 및 코드 구현  

> Cucumber, BDD(행위 주도 개발)  
> 1. 하나의 시나리오에 집중한다.
> 2. 실패하는 단계를 정의한다  
> (단위테스트) -> 한 단계를 통과할 때까지 이 과정을 반복  
> 3. 실패하는 테스트를 구현한다.
> 4. 테스트가 통과되도록 한다.
> 5. 리팩토링한다.  
> 6. 한 단계를 통과했다면, 리팩토링  
> 모든 시나리오가 완료될 때까지 1-7을 반복  
> 하나의 시나리오가 완료될 때까지 2-7을 반복  

[코드](https://github.com/building-microservices-with-go/chapter4)  

## 단위 테스트  
테스트의 세가지 법칙  
* 첫 번째 법칙: 실제 코드를 작성하기 전에 실패하는 단위 테스트를 먼저 작성한다.  
* 두 번째 법칙: 컴파일에 실패하지 않으면서 실패하기에 충분한 수준으로만 단위 테스트를 작성한다.  
* 세 번째 법칙: 현재 실패하는 테스트를 통과할 수 있는 수준으로만 실제 코드를 작성한다.  

Go에서 마이크로서비스를 테스트하는 가장 효과적인 방법 중 하나: HTTP 인터페이스를 통해 모든 테스트를 실행하려고 하는 함정에 빠지지 않는 것  
-> 물리적인 웹 서버를 만들지 않아도 핸들러를 테스트할 수 있는 패턴을 개발할 필요가 있음  

규칙: 테스트 파일은 테스트가 속한 패키지와 동일한 폴더에 만들고 그 외 규칙은 <테스트 코드 in GO> 참고   

단위 테스트의 기본: 의존성 제거  
모의 객체(Mock, 테스트를 위해 만든 동일한 인터페이스를 가진 가짜 객체) or 스파이(Spy, 실제 인스턴스를 테스트용 목으로 사용)으로 의존성 대체  

```go test -v -race ./...```  
* -v : 상세 출력 형식, 테스트가 성공하더라도 애플리케이션이 출력한 모든 텍스트 보여줌
* -race: 동시성 문제가 있는 버그를 발견하는 Go의 레이스 탐지기를 활성화  
두 개의 Go루틴이 동일한 변수에 동시에 접근하며 그 중 하나 이상이 쓰기 접근인 경우 데이터 레이스가 발생  
테스트 실행에 크게 부담이 되지 않으므로 실행 시에 항상 추가하는 것이 좋음  
* ./... : 현재 폴더와 하위 폴더의 모든 테스트를 실행할 수 있음 -> 테스트할 패키지 or 파일 목록을 수동으로 작성하지 않아도 됨  

그 후 테스트를 가지고 테스트를 통과하기 위한 구현 코드 작성  

중복된 코드로 인한 나쁜 테스트는 나쁜 코드보다 더 해로움  
-> 공통으로 사용하는 메서드 작성. 테스트를 세 가지 핵심 영역에 집중시킴  
-> 설정 Set up / 실행 Execute / 단정 Assert  

## 의존성 주입 & 모의 객체 만들기  
데이터 저장소를 데이터베이스에 구현 or 간단한 인-메모리(메모리 내부에 구현) 저장소에 구현 등  
-> 실제 데이터 저장소에서 테스트를 실행하지 않고 데이터 저장소와 처리기를 모두 테스트할 수 있어야 함  
=> 이를 위해 의존성 주입(dependency injection)이라는 기술 사용  

핸들러 내부에서 의존성을 작성하는 것이 아니라 외부에서 핸들러로 의존성 절달  
핸들러를 테스트할 때 이러한 의존성이 있는 코드를 스텁 또는 모의 객체로 대체해 의존성을 제어하고 호출하는 코드가 여기에 반응하는 방식을 확인할 수 있음  
직접 모의 객체를 만들 수도 있지만 [우수한 패키지](https://github.com/stretchr/testify) 사용  


## 테스트 코드 in GO  
Go는 간편하게 사용 가능한 테스트 프레임워크 내장  

* ```go test``` 명령 실행하여 테스트 코드 실행 가능  
* ```go test```는 현재 폴더에 있는 ```*_test.go``` 파일들을 테스트 코드로 인식, 일괄적으로 실행  
* 테스트 파일은 "testing"이라는 표준 패키지 사용  
* 먼저 testing 패키지 import 하고, 테스트 메서드 작성  
* 테스트 메서드는 TestXxx와 같은 특별한 메서드명 가짐(Test-해당 메서드가 테스트 메서드임을 알림 / Xxx-임의의 메서드명으로 처음 글자는 항상 대문자여야 함)  
그 외 Example, Benchmark 등이 있으며 이 기능들을 함수 이름에 접두사로 사용하는 것을 권하고 있음  
* 테스트 파일은 ```_test``` 접미사 달고 있으면 됨. 즉 ```*_test.go``` 형식  

## 메서드의 ProtoType  
> func TestXxx(t *testing.T)  
> Test로 시작해 바로 대문자 또는 숫자가 나오는 특수한 이름  

testing.T 포인터를 하나 입력으로 받고, 출력은 없음  
테스트 에러 표시는 testing.T의 Error(), Fail() 등의 메서드 사용  

## 테스트 코드 예제  
* 테스트를 할 함수  
```
package calc
 
// Sum -
func Sum(a ...int) int {
    sum := 0
    for _, i := range a {
        sum += i
    }
    return sum
}
```  

* Sum() 함수를 테스트할 테스트 코드  
* 테스트 패키지명을 calc가 아닌 calc_test로 설정  
* 파일명을 *_test.go로 설정  
```
package calc_test
 
import (
    "calc"
    "testing"
)
 
func TestSum(t *testing.T) {
    s := calc.Sum(1, 2, 3)
 
    if s != 6 {
        t.Error("Wrong result")
    }
}
``` 

* 테스트 코드 실행(유닛 테스트 파일이 /src/calc/calc_test.go 라는 경로에 있을 때)  
```
~/goapp/src/calc$ go test
PASS
ok      calc    0.007s
```  

## assert 패키지  
* 테스트 코드 양에 따라 if가 난무하는 코드가 될 수 있어 [assert 패키지](https://github.com/stretchr/testify)의 도움을 받는 것이 좋음  
* 좀 더 시각적인 output 제공 가능  

## gotests  
테스트 코드를 자동으로 생성해주는 도구이자 IDE 플러그인  
[깃헙](https://github.com/cweill/gotests)  



## 출처  
* http://golang.site/go/article/115-Go-%EC%9C%A0%EB%8B%9B-%ED%85%8C%EC%8A%A4%ED%8A%B8  
* https://box0830.tistory.com/371  
* https://www.hahwul.com/2021/07/11/easy-make-golang-test-code-with-gotests/
* Go 언어를 활용한 마이크로서비스 개발, 닉 잭슨 지음, 이상식 올김, 에이콘 출판사  


