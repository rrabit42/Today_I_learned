# Klaytn 클레이튼 스마트계약과 탈중앙앱  

교육 자료: [Klaytn 클레이튼 스마트계약과 탈중앙앱](https://www.inflearn.com/course/klaytn-%EC%8A%A4%EB%A7%88%ED%8A%B8%EA%B3%84%EC%95%BD%EA%B3%BC-%ED%83%88%EC%A4%91%EC%95%99%EC%95%B1#curriculum)  


## 0. 블록체인 기본  

- **블록체인**이란? 정보를 **블록**이라고 하는 단위로 젖아하여 저장된 블록들을 **체인**형태로 묶은 저장 기술  
데이터들은 일정한 순서로 정렬되어 묶음으로 저장되는데 이를 '블록'이라고 함. 첫번째 블록(Genesis Block)에서 시작되어 블록들은 서로 체인으로 연결되고 이 순서는 유지가 됨.  
Linked List와 비슷한 형태지만 앞의 블록을 기억하는 방법이 다름(해시 함수 사용). 

- **블록, 블록헤더, 해시포인터**?  
자료구조: 누가 누굴 기억하느냐가 중요(뒤가 앞을 기억? 앞을 뒤가 기억?), 메모리 주소에 데이터를 매핑하므로 메모리 주소를 기억  
블록은 헤더와 바디로 구분. 헤더는 블록을 설명하는 정보와 이전 블록의 해시 포함. 이전 블록의 해시(hash pointer)를 가지기 때문에  
(1) 어떤 블록이 앞에 와야하는지 결정적으로 알 수 있고 (2) 이를 바탕으로 블록의 순서를 결정할 수 있음  
바디는 정보의 묶음. 이 데이터를 설명해주는 헤더(이 묶여진 일련의 데이터들을 어떻게 검증해야하는지, 검증에 무엇이 필요한지 등의 정보)  

- **블록높이, 블록생성주기**?  
블록체인을 처음에 구상한 사람들은 수직으로 0번이 바닥에 깔리고 그 위로 쌓이고, 0번을 빼버리면 모든게 흔들려 버린다고 생각. 그래서 차곡차곡 쌓아 올린다고 생각. -> 높이 개념 등장  
블록들을 이전 블록이 아래에 최근 블록이 위로 오도록 정렬하면 블록이 생성됨에 따라 체인의 높이가 늘어난다. 블록의 순서를 그 블록이 위치한 '높이'(block height)라 부른다. 첫번째 블록은 편의상 높이를 0이라 한다.  
다음 블록을 생성하기까지 걸리는 시간을 '블록생성시간'이라 하고, 블록생성시간이 비교적 일정한 경우 '블록생성주기'란 표현을 사용. (대부분은 주기마다 만듦, 비트코인은 10분, 이더리움 15초 정도에 수렴, 클레이튼 1초)  
블록생성주기는 아주 중요하다. 데이터가 블록에 들어가게 되는걸 '체결'. 체결시간이 짧을 수록 서비스에 적합하기 때문. (클레이튼은 서비스 지향적인 블록체인)  

- **블록체인 네트워크, 노드**?  
보통 우리가 아는 Request-Response(Client-Server) 구조. 연산력이 부족하거나 컨텐츠가 부족한 클라이언트가 반대로 연산 능력이 충분하거나 콘텐츠가 충분한 서버에게 요청하고 응답을 받음.  
그러나, 블록체인은 기본적으로 P2P 네트워크(Peer-to-Peer Network) ex) 토렌트, 소리바다(누구 한명에게 의존하는 구조 X. 나와 같은 데이터를 가진 다른 사람이 그 데이터를 줄 수 있음. 빠진 데이터 채우기 -> 탈중앙화)  
블록체인은 한명 이상의 참여자(노드)가 있는 네트워크에서 관리.  
네트워크 참여자 전원은 모든 블록을 동일한 순서로 저장하여 모두 같은 블록체인을 유지.  

- **합의(Consensus)**?  
중앙이 원장을 가지고 있고, 우리는 모두 중앙을 믿고 의존함. ex) Alice의 잔고가 실제로 100불인거 맞아? 중앙은행한테 물어보고 은행이 검증해줌. 은행이 모든 사람들의 돈이 적힌 원장을 가지고 있으니까.  
블록체인은 모두가 원장을 가지고 있고, 모두가 기억을 할 수 있으므로 모두가 검증을 할 수 있음. 그러므로 모두의 합의가 필요한 상황이 있음 ex) Alice가 50불을 Bob에게 보낼 수 있는지 없는지 맞아?  
자격이 있는 참여자는 블록을 제안(propse)할 수 있음: 제안자(Proposer)  
블록 제안 자격은 네트워크마다 상이 (e.g., PoW: 제안자의 익명성은 지켜지지만 제안자의 work을 통해 올바른 참여자라고 생각하여 그 블록을 받아들여줌)  
노드들은 제안자가 올바른 자격을 취득했는지, 제안된 블록이 올바른지 **검증** 뒤 블록을 자신의 체인에 추가. ex) 나는 Alice가 50불을 보낼 수 있는게 맞는 것 같아.  
정족수 또는 정해진 기준을 만족하는 수의 노드가 블록을 자신의 체인에 추가하면 합의가 이뤄졌다고 판단.  ex) 누군가가 이 데이터를 다음 블록이라고 하자 -> 나는 그 액션에 동의해(이 과정이 합의)  
그러나 합의가 어려운 이유: **[비잔틴 장군 문제](http://wiki.hash.kr/index.php/%EB%B9%84%EC%9E%94%ED%8B%B4_%EC%9E%A5%EC%95%A0_%ED%97%88%EC%9A%A9)**  


> 정리: 블록체인의 성질
> - 블록체인은 한명 이상의 참여자가 있는 네트워크에서 관리
> - 네트워크 참여자 전원은 모든 블록을 동일한 순서로 저장하여 모두 같은 블록체인 유지
> - 자격이 있는 참여자는 블록을 제안할 수 있음; 블록 제안 자격은 네트워크마다 상이
> - 블록이 체인에 추가됨 = 참여자들이 새 블록을 자신의 체인에 추가
> - 따라서 새로운 블록이 체인에 추가되려면 네트워크의 합의가 필요; 합의방법은 네트워크마다 상이  
> (어느 한 주체가 단독으로 결정하는 구조가 아닌, 여러 참여자가 합의를 통해 결정하기 때문에 블록체인은 탈중앙화되어 있다고 표현)  
> - 참여자 전원은 이전 블록들을 저장하고 있으므로 새로운 블록의 무결성을 확인 가능  
> - 새롭게 제안되는 블록은 참여자들이 검증 및 합의할 수 있는 형태여야 함(투명성)  -> 그럼 모두가 이전 기록을 알 고 있어야 하니까 투명하다!  
> - 한번 쓰여진 블록은 이전의 합의를 번복할 수 있지 않는 한 변경될 수 ~~없음~~(불변성) -> 거의 불가능하다. 정말 많은 사람이 알고 있으니 변경이 힘들다!  

- - -

### **합의 알고리즘**  

구분|PoW|PoS|BFT-variants
---|---|---|---
제안자격 취득 방법|계산이 어려운 문제를 풀 것|플랫폼 토큰을 보유한 양과 기간에 따라 결정적으로 또는 확률적으로 뽑힐 것|정해진 순번 또는 정해진 확률에 의해 뽑힐 것
네트워크 참여 제한|없음|없거나 낮음|높음
합의에 필요한 연산량|높음|낮음|낮음
위협|전체 연산량의 51%를 한 참여자가 소유할 경우 중앙화됨|전체 토큰의 51%를 한 참여자가 소유할 경우 중앙화 됨|전체 참여노드의 1/3 이상이 담합할 경우 합의 불가, 전체 참여노드의 2/3 이상이 담합할 경우 중앙화됨
대표적인 블록체인|Bitcoin, Litecoin, Etherum, Monero, QTUM|Etherum FFG&CFG, EOS(dPoS)|Klaytn, Tendermint, Hyperledger Fabric, Ontology

PoW: Nonce를 추가해서 해시를 하는데 가장 작은 값을 구했을 때(앞의 0의 개수가 가장 많을 때), GPU 마이닝, 참여 제한은 없지만 참여가 힘들다(해시파워)  

longest chain 구조: 블록을 빠르게 생성하는 사람이 다음 블록 결정 -> majority attack  
장점: 누구나 참여할 수 있다 -> 네트워크를 비동기화 상태에 두어도 합의를 이끌어낼 수 있다  
단점: 연산에 쓰는 비용이 비싸다  

PoS: 토큰의 총량이 있음, 따라서 누군가 토큰을 매집해 버리면 공격 가능

BFT-variants: 많이 느렸지만 지금 개선이 되어서 빨라짐(Klaytn은 1초에 TPS가 4000, 1초에 4000개의 tx를 블록에 담을 수 있다).  
네트워크가 동기화 되어있다.(네트워크에 참여하는 사람이 누군지 모두가 알고 있고 바뀌지 않는다.  
누가 추가되기가 어려운게 추가가 되면 하던일 멈추고 모두가 새로운 사람을 다 아는 상태가 된 후에 시작).  
통신량이 많아서 참여자가 많을 수록(20명만 되도) 느려짐(즉, 소규모 그룹에 적합, 15명 이상부터 느려짐).  
따라서 PoW, PoS보다 참여자들의 높은 신뢰성이 담보되어야 함.  

- - -

- **블록체인의 비교** Public vs Priate?  
퍼블릭과 프라이빗의 구분은 다음을 수행할 수 있는지 확인하여 결정:  
(1) 누구든지 기록된 정보(블록)를 자유롭게 읽을 수 있는지?  
(2) 명시적인 등록 또는 자격취득 없이 정보를 블록체인 네트워크에 기록할 수 있는지?  
블록체인의 정보가 공개되어 있고 네트워크가 정한 기준(e.g., gas fee)에 따라 정보를 기록요청할 수 있다면 그 블록체인은 퍼블릭/ 공개형이라 한다.  
이와 반대로 정보가 공개되어 있지 않고 미리 자격을 득한 사용자만이 정보를 기록할 수 있다면 그 블록체인은 프라이빗/비공개형이라 한다.  

- **블록체인의 비교** Permissionless vs Permissioned?  
일반적으로 네트워크의 참여가 제한된 경우 'permissioned', 그렇지 않은 경우 'permissionless'라 정의  
네트워크의 참여의 정의  
-(넓은 의미) 블록체인 P2P 네트워크에 참여  
-(좁은 의미) 합의과정의 참여  

> Public/Private 개념이 정보의 접근성(Access)와 관련이 있다면  
> Permisionless/Permissioned는 정보의 제어(Control), 즉 무엇이 블록에 포함되는지를 결정하는 지에 더 밀접한 개념  
> ex) PoW, PoS는 네트워크에 참여하면 합의에 참여도 가능한데, 비잔틴은 네트워크에 참여(정보 읽고 쓰기...)는 해도 합의(다음 블록이 무엇인지 정할 수 있는 권한)에 참여는 어려움.

- - -

### **공개키 암호화와 전자서명**  
블록체인에서는 비대칭키암호(공개키) 사용.  
공개키와 비밀키는 한쌍으로 묶여있는 아주 큰 숫자들. 비밀키로부터 공개키를 도출하는 것은 쉬움. 공개키로부터 비밀키를 찾는 것은 매우 어려움.(브루트 포스해도 어려움)  
전자서명: 비대칭키암호는 지정된 사람만 정보를 확인할 수 있도록 도움(privacy). 전자서명은 누가 정보를 보냈는지 알기 위해 사용(non-repudiation).  
해시: 변조 여부 판단 가능  

### **블록체인에서 사용되는 암호화 기법**
블록체인과 공개키 암호: 암호학적으로 주소의 소유권 확인을 위해(왜냐하면 주소 생성 때 신원 확인 등의 관여를 안하니까)  
블록체인은 암호학적 기법을 토대로 만들어진 기술  
비트코인은 네트워크 참여자 모두가 같은 '원장'을 공유함으로써 투명한 거래가 가능  
원장은 어느 주소에 BTC가 있는지 기록하지만 그 주소가 누구에게 속하는지는 기록하지 않음(anonymity)  
비트코인은 공개키암호를 사용하여 명시적인 비밀교환과정 없이 BTC 소유권 증명을 실행  

### **공개키 암호화를 사용한 소유권 증명**  
대부분의 블록체인 주소는 공개키로부터 도출된 값  

- Bitcoin: Hash160 of a public key where Hash160 = RIPEMD160 + SHA256. 
임의의 주소 X에 10 BTC가 있다고 가정할 때 Alice는 X에서 또 다른 임의의 주소 Y로 5 BTC를 전송(i.e., transfer 5 BTC from X to Y)하는 거래를 성사시키기 위해 X로 변환되는 공개키와 짝을 이루는 비밀키로 해당 거래를 서명할 수 있어야 한다.  

- Ethereum: Rightmost 160 bits of Keccak hash of a public key.  
임의의 주소 X에 위치한 어카운트의 잔고에 10 ETH가 있다고 가정할 때 Alice는 X에서 또다른 임의의 주소 Y에 위치한 어카운트로 5 ETH 전송(i.e., transfer 5 ETH from the account at X to the account at Y)하는 거래를 성사시키기 위해 X로 변환되는 공개키와 짝을 이루는 비밀키로 해당 거래를 서명할 수 있어야 한다.  

tx를 비밀키로 서명하고 이 서명과 함께 공개키를 같이 보냄. 이 공개키로 서명 검증, 또 공개키를 160 비트로 줄여봤더니 주소와 동일.  
But, 그럼 공개키도 같이 따라가야 해서 네트워크 페이로드 낭비(전자서명 256bit + 공개키 256bit), tx이 많아지면 비효율적으로 됨.  
이더리움이 서명으로부터 공개키를 도출하는 기술(오!)를 사용.  

- - -

### **구현 방법으로 나눠본 블록체인**

**UTXO(Unspent Transcation Output) 기반 블록체인**  
블록체인에 사용 가능한 토큰(e.g., Bitcoin) - UTXO들과 사용 자격검증방법을 기록  
일반적인 자격검증방법은 UTXO의 정보와 일치하는 공개키로 검증가능한 전자서명을 제출하는 것  
Bitcoin이 대표적인 UTXO 기반 블록체인  
-> 돈에다가 주소를 준 것, 돈이 그 자체로 암호화 되어 있음, 그 돈을 쓸 때 전자서명을 줌  
-> 보안성 강화, 병렬화 가능(돈과 전자서명 매칭)  

**어카운트 기반 블록체인(Account-based Blockchain)**  
어카운트는 블록체인을 구성하는 주체(entity)를 표현하며 상태를 기록  
사용자는 어카운트를 사용할 때마다 어카운트 공개키로 검증 가능한 전자 서명을 생성  
상태를 기록할 수 있기 때문에 스마트 컨트랙트를 구현하기에 용이  
Etherium, Klaytn이 대표적인 어카운트 기반 블록체인  
-> 어카운트에 주소를 준 것. 그 어카운트가 balance라는 상태 값 가짐, 어떤 어카운트를 사용하기 위해 전자서명을 줌  
-> 어카운트 기반이라 병렬화 불가능(순서대로 해야함)  
-> 대신 상태라는게 생김(상태가 없으면 그냥 일회성 프로그램)  

- **Ethereum 어카운트, 주소, 상태**?  
Ethereum의 어카운트는 Ethereum의 주체(entity)를 표현하고 그 상태를 기록하는데 사용  
어카운트는 EOA(Externally Owned Account)와 스마트 컨트랙트로 구분  
Ethereum 사용자는 EOA를 사용  
사용자는 임의의 공개키와 비밀키 쌍(Key Pair)을 생성한 뒤 공개키를 어카운트 주소로 변환하여 EOA를 생성  
-> 별도의 승인 과정이 필요없으며 Ethereum 네트워크와 통신도 필요 없음  
-> 위 과정으로 인해 어카운트는 특정 키페어에 종속  
사용자의 상태(state)는 어카운트 주소로 찾을 수 있는 블록체인 저장공간에 기록  

+) 비밀키로 공개키가 나오고 그 공개키를 주소로 바꿀 수 있다. 주소는 컴퓨터 메모리와 같은데, 그 주소에 어떤 사용자의 어카운트가 표현되어 있다.
거기에 status(상태)가 있는데 거기에 밸런스도 있고, 지금까지 tx 몇 개 발생시켰는지 등이 나옴.  

- - -

### **트랜잭션(Transaction, TX)**  
블록체인의 저장 구조에서 보면 저장의 단위, 정보의 단위.  
데이터는 트랜잭션 단위로 저장이 되고, 트랜잭션들은 일정한 순서로 정렬되어 묶음으로 저장
- 블록은 트랜잭션을 일정한 순서로 정렬하여 저장하는 컨테이너  
- 트랜잭션은 어카운트의 행동  
- 트랜잭션의 순서는 중요!!; TX_1 -> TX_2와 TX_2 -> TX_1는 다름 ex) 돈을 이미 줘서 잔고가 없는데 tx 뒤바뀌면 말이 안되게 되잖아!  
- 블록체인 참여자들은 블록을 검증할 때 트랜잭션들이 올바른 순서대로 정렬되었는지를 확인 후 합의  
- 각각의 트랜잭션들은 어카운트에 연결된 공개키로 검증가능한 서명을 포함  

> Alice가 tx를 블록체인 노드에 보내줌. 노드는 이 트랜잭션을 최대한 빨리 들어가게 하기 위해 다른 노드에게도 tx를 보내줌. 다른 애가 블록을 더 빨리 생성할 수 있으면 이 tx이 빨리 들어갈 수 있으니까.  
> 어떤 노드가 블록을 제안했는데 그때 Alice의 tx가 들어가면, 그래서 체인에 tx가 추가되면  
> 이 tx이 "1 confirmation 받았다"고 표현함. 즉, 체결 되었습니다!  
> 해당 블록 뒤에 블록이 체결될 때 마다 confirmation 수가 들어감. 즉, 높이 4인 블록에서 이 tx은 1 confirmation, 높이 5인 블록에서는 2 confirmation. 
> 즉, tx이 포함된 블록은 점점 아래에 묻히게 됨

> **이게 중요한 이유!**  
> 블록은 어느 순간 번복될 수 있음.  
> -> 비트코인, 이더리움 같이 탈중앙화되어 있는 한쪽 end node 다른 end node 사이의 네트워크 딜레이가 크다. 둘 다 거의 비슷한 시간에 문제를 풀었을 때, 주변 동네에서는 그 블록들이 각각 인정 받음.  
> -> 중간 지점에는 헷갈림. 누가 먼저인가?! 판단이 어려우니 경쟁이 시작, 나는 A 블록이 맞다고 생각하니 A를 기반해서 블록을 쌓아 나갈 거야 등  
> -> longest 체인이 더 빨리 되기 위해 경쟁을 함, 해시파워가 큰 쪽이 이기게 됨. longest chain만 선택 받음. PoW를 가장 긴 체인의 마지막 블록 기준해서 돌려야 내 블록이 포함될 수 있음. 그래야 내가 리워드를 받으니까.(경제적으로 맞는 선택)  

- - -

### **Understanding Bitcoin's 6 Confirmations Rule**  
- Confirmation 숫자는 트랜잭션이 블록에 포함된 이후 생성된 블록의 숫자 ex) 임의의 트랜잭션 T가 포함된 블록의 높이가 100, 현재 블록높이가 105라면 T의 confirmation 숫자는 6  
- PoW를 사용하는 블록체인들은 finality가 없기 때문에 confirmation 숫자가 중요 (e.g., 약간의 네트워크 딜레이로 1-2개 차이는 날 수 있는데, 몇 개 이상 차이나기는 확률적으로 어려움. Bitcoin은 6개, Ethereum은 7개 제한)  
- Finality란 블록의 완결성을 의미(합의를 통해 생성된 블록이 번복되지 않을 경우 완결성이 존재)  
- PoW 기반 합의는 확률에 기반하기 때문에 경우에 따라 블록이 사라질 수 있으므로 완결성이 부재함  
-> PoW 블록체인은 수학적으로 복잡한 퍼즐을 풀어 블록을 제안할 자격을 얻는 구조  
-> 만약 두명의 서로 다른 참가자가 동시에 퍼즐을 풀어 두개의 올바른 블록을 생성한다면 두 블록 중 하나는(eventually) 사라지게 됨  
-> 이 때문에 블록이 확률적 완결성를 갖기까지 일정 갯수 이상의 블록이 생성되기를 기다려야 함.  
즉, 블록에 완결성이 없다 = 그 블록이 사라질 수 있다.  

네트워크 시차로 인해 생성된 우연한 복수의 블록들 가운데 하나가 선택되는데 필요한 블록은 두어개 정도 -> 2~3 confirmations  
퍼즐을 빠르게 풀 수 있는 악의적인 참여자(공격자)가 있을 경우 그 참여자의 해시능력(hash power)에 따라 필요한 confirmation 숫자가 달라짐  
- 해시능력이 높을 수록 퍼즐을 푸는 속도도 빠르기 떄문에 주어진 문제를 먼저 풀 확률이 높아짐  
- 해시 능력이 높은 참여자는 longest chain을 임의로 선택 또는 생성할 수 있음  
- 따라서 해시능력을 감안하더라도 임의의 블록체인을 변경하지 못할 정도로 충분히 많은 블록이 생성되기를 기다려야할 필요가 생김  
- Bitcoin의 6 confirmation 법칙은 공격자가 전체 해시능력의 약 25%를 가질 때를 가정한 숫자
(공격자가 존재할 때를 가정해서, 대단한 해시파워를 가진 사람이 악의적으로 블록을 추가할 때 몇 번의 confirmation을 받아야 안전하게 내 tx이 블록에 포함되었는지 확신할 수 있는가)  
- 99.9%의 확률로 내 tx이 포함된 블록을 final 함. (0.1% 문제는 여전히 있는 것 -> 따라서 비트코인, PoW의 finality를 확률적 finality라고 함)  

> #Confirmations to wait if...  
> PoW 블록체인이 공격자가 전체 해시능력의 x%를 가질 때 99.9% 완결성을 확보하려면 다음과 같은 confirmation 숫자가 필요:  

x|# confirmations|기다려야하는 시간
---|---|---
10|4|40
25|7|1시간 10분
33|10|1시간 40분
49|170|2시간 50분

여전히 담합의 여지가 있다.  

- - -

### **BFT 기반 블록체인**  

많은 통신이 이루어지는 대신 합의해서 만든 블록은 만들어진 그 시점에 모두 final 함.  

BFT기반 블록체인은 블록의 완결성이 보장됨.  
- 네트워크가 동기화되어 있기 때문  
- 블록 생성이 PoW에 비해 빠르고 경제적  

하지만 네트워크 동기화의 필요로 인해 참여자의 숫자가 제한됨(~~중앙화되기 쉬움~~)  
- 네트워크 참여자 구성이 고정되어 있어야 합의가 가능  
- 구성이 변경될 경우 모든 네트워크 참여자가 새로운 구성을 인지하기까지 합의 불가능  
- 합의 알고리즘이 네트워크 동기화를 가정하고 짜여졌기 때문에 네트워크 사용량이 높음  
- 참여자가 많아질 경우 네트워크 오버헤드로 인해 합의가 느림  

- - -

## 1. 블록체인 상태와 트랜젝션  

### Klaytn BFT  
- Klaytn은 확장가능한 BFT을 사용(네트워크에 참여하는 전체 집합을 대상으로 BFT를 실행하지 않음!)  
> N개의 노드 가운데 S개의 부분노드 집합을 확률적으로 선택(where N is large, and S is sufficiently small). 
> 전체집합을 거버넌스 카운실(Governance Council),  
> 부분집합을 커미티(Committee)로 정의  
> 커미티 선택은 VRF(Verifiable Random Function)로 구해진 무작위값에 기반  

- 매 블록마다 새 커미티를 뽑아 BFT를 실행  
- 기존의 BFT에 비해 확장성을 크게 개선

Klaytn이 BFT를 선택한 이유  
PoW가 너무 느리고, 비용도 많이 들기 때문에  
PoS는 누군가가 과반을 점유하기 너무 쉬운 구조라서(자금을 많이 가진 사람)  

따라서 PoW로 먼저 시작하고 다양한 사람이 코인을 소유하면 그 때 PoS로 전환함(PoS로 먼저 시작하는 코인은 없음)  

- - -

### 블록체인의 상태(Blockchain State)  

* (어카운트 기반) 블록체인의 상태  
블록체인은 트랜잭션으로 변화하는 상태 기계(State Machine)  

